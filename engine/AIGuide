Name: The name of the action, as given by followups.
Class: The class that this information is associated with. 
Input: The frame-by-frame input required to make this move work. 
    - Frame number: Input map
Prerequisite: An expression indicating what must be true for this to be possible. 
Pattern: A list indicating the frame pattern of this move. 
    - Start: Inclusive start frame
      End: Inclusive end frame
      Hitbox: A 4-vector indicating the bounding box of the fighter during this move. ({self.rect.centerx-self.rect.left, self.rect.right-self.rect.centerx, self.rect.centery-self.rect.top, self.rect.bottom-self.rect.centery})
      LandingLag: Used to determine how badly the ground should be avoided for this move. Set negative to make it favor the ground during this part of the move. 
      Follow: A list indicating hit regions and their effects
          - Hitbox: A tuple that can then be fed to a pygame.rect constructor to construct a rectangle indicating where the opponent's center must be for the move to connect. 
            Follow: A list of actions that can follow the move if this is the last move that connects. 
            Priority: How much of an advantage the move lends if the opponent acts neutrally and this move connects here. 0 is neutral, higher is better. 
            Type: A 2-vector expressing how much defense and how much pierce the move yields. Higher magnitudes indicate more polarized moves. 
              [0, -1]: Medium defense, low pierce. (Ex: Armored smash attacks)
              [1, 0]: High defense, medium pierce. (Ex: Shields)
              [0, 1]: Medium defense, high pierce. (Ex: Fast standing grabs)
              [-1, 0]: Low defense, medium pierce. (Ex: Shield pokes)
            Precedence: If multiple areas connect, which one gets followed up on? Highest precedence wins. 
            Connect: A short, simple python script that indicates what happens if this move connects. (This takes the place of update() in the evaluation)
